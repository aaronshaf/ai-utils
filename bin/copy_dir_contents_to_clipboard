#!/bin/zsh

# -----------------------------
# Script: copy_dir_contents_to_clipboard
# Description:
#   Recursively copies the names and contents of specified non-binary textual files
#   to the clipboard, skipping node_modules, hidden directories, and respecting .gitignore.
#   Only includes files with extensions: .md, .json, .ts, .tsx, .js, .jsx
#
# Usage:
#   copy_dir_contents_to_clipboard dir1 dir2 file1 ...
#
# Example:
#   copy_dir_contents_to_clipboard src tests package.json
# -----------------------------

# Ensure essential directories are in PATH
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"

# Define the file extensions to include
EXTENSIONS=("md" "json" "ts" "tsx" "js" "jsx")

# Function to check if a file has one of the desired extensions
has_valid_extension() {
    local file="$1"
    for ext in "${EXTENSIONS[@]}"; do
        if [[ "$file" == *.$ext ]]; then
            return 0
        fi
    done
    return 1
}

# Initialize an empty array to hold file paths
file_list=()

# Function to collect files respecting .gitignore if inside a git repository
collect_files_git() {
    # Collect tracked files
    local tracked
    tracked=$(git ls-files "$@")
    # Collect untracked but not ignored files
    local untracked
    untracked=$(git ls-files --others --exclude-standard "$@")
    # Combine both lists
    file_list+=("${(f)tracked}" "${(f)untracked}")
}

# Function to collect files using find, excluding node_modules and hidden directories
collect_files_find() {
    for arg in "$@"; do
        if [[ -d "$arg" ]]; then
            # Use find to locate files, excluding node_modules and hidden dirs
            local files
            files=$(find "$arg" \
                \( -path "*/node_modules/*" -o -path "*/.*/*" \) -prune -o \
                -type f -print 2>/dev/null)
            file_list+=("${(f)files}")
        elif [[ -f "$arg" ]]; then
            file_list+=("$arg")
        else
            echo "Warning: '$arg' is not a valid file or directory." >&2
        fi
    done
}

# Determine if we're inside a git repository
if git rev-parse --is-inside-work-tree &>/dev/null; then
    collect_files_git "$@"
else
    collect_files_find "$@"
fi

# Filter the files by the desired extensions
filtered_files=()
for file in "${file_list[@]}"; do
    if has_valid_extension "$file"; then
        filtered_files+=("$file")
    fi
done

# Remove duplicate files (in case of overlapping paths)
filtered_files=($(printf "%s\n" "${filtered_files[@]}" | awk '!seen[$0]++'))

# Prepare the aggregated output
output=""
for file in "${filtered_files[@]}"; do
    # Ensure the file exists and is a regular file
    if [[ -f "$file" ]]; then
        # Check if the file is textual
        if file "$file" | grep -qiE 'text|source'; then
            # Append file path and its content to the output
            output+="### File: $file\n"
            output+="----------------------------------------\n"
            # Escape any backslashes and backticks to prevent markdown issues
            content=$(sed 's/\\/\\\\/g; s/`/\\`/g' "$file")
            output+="$content\n\n"
        fi
    fi
done

# Copy the output to the clipboard
# Use pbcopy for macOS, xclip or xsel for Linux
if command -v pbcopy &>/dev/null; then
    echo -e "$output" | pbcopy
    echo "✅ Copied ${#filtered_files[@]} files to clipboard using pbcopy."
elif command -v xclip &>/dev/null; then
    echo -e "$output" | xclip -selection clipboard
    echo "✅ Copied ${#filtered_files[@]} files to clipboard using xclip."
elif command -v xsel &>/dev/null; then
    echo -e "$output" | xsel --clipboard --input
    echo "✅ Copied ${#filtered_files[@]} files to clipboard using xsel."
else
    echo "❌ No clipboard utility found (pbcopy, xclip, or xsel)." >&2
    exit 1
fi
